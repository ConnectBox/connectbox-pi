---
- name: Make connectbox directory
  file:
    state: directory
    path: /usr/local/connectbox
    mode: 0755

# Needs to happen prior to partitioning
- name: Create moodledata directory that Moodle requires for all its functions
  file:
    state: directory
    path: /var/www/moodledata/
    owner: www-data
    group: www-data
    mode: 0775

###########################################

# Raspberry Pi partitioning for building via Ansible
- name: Get Name of SD card
  shell: lsblk -d | grep mmcblk0 | awk '{print $1;}'
  register: sdcard_name
  when: connectbox_os == "raspbian"

- name: Read SD card information 
  community.general.parted: device=/dev/{{ sdcard_name.stdout }} unit=MiB
  register: sdcard_info
  when: connectbox_os == "raspbian"
  
- name: Extend the existing OS partition to 4 GB so we have enough space to load all The Well software
  community.general.parted:
    device: /dev/{{ sdcard_name.stdout }}
    number: "{{ sdcard_info.partitions | length }}"
    part_end: "4GB"
    resize: true
    state: present
  ignore_errors: yes
  when: connectbox_os == "raspbian" and sdcard_info.partitions[1].size < 5000

- name: Complete the resize filesystem of OS partition 
  command: resize2fs /dev/{{ sdcard_name.stdout }}p2
  become: true
  when: connectbox_os == "raspbian" and sdcard_info.partitions[1].size < 5000

- name: Re-Read SD card information 
  community.general.parted: device=/dev/{{ sdcard_name.stdout }} unit=MiB
  register: sdcard_info
  when: connectbox_os == "raspbian" and sdcard_info.partitions[1].size < 5000


##########################################
# Set default passwords
- name: Change user password
  user:
    name: pi
    update_password: always
    password: "{{ connectbox_system_password|password_hash('sha512') }}"

- name: Change user password
  user:
    name: root
    update_password: always
    password: "{{ connectbox_system_password|password_hash('sha512') }}"
  become: true
  
- name: Check for release of OS  
  command: lsb_release -a
  register: OS_Release

- name: Look for Bullseye
  register OS_Bullseye
  debug:
    msg: "Found were running Bullseye"
  when: OS_Release.stdout.find("bullseye") != -1


# Check early on to see if the style of interface names need to be changed
#  (only applicable to Ubuntu, and not when we're running virtualised)
# We do this before the check for the Armbian reboot oracle. If we need
#  to reboot to activate the old-style interface names, we'll sort out the
#  reboot oracle too, but if the reboot oracle check is before this check
#  we'll need to reboot a second time (after creating the symlink)

- name: Check for release of OS_Release
  command: lsb_release -a
  register: OS_Release

- name: Check the OS_Release for OS_Bullseye
  debug:
    msg: "Found were running Bullseye"
  register: OS_Bullseye
  when: OS_Release.stdout.find("bullseye") != -1

- debug:
    msg: "Ansible Group Variables Family {{ ansible_os_family|lower }}"

- debug:
    msg: "Ansible Group Variables Distribution {{ ansible_distribution|lower }}"

- debug:
    msg: "Ansible Group Variables Target Specific {{ ansible_lsb['id']|lower }}"

- debug:
    msg: "Machine Type file {{ machine_type['stdout_lines'] }}"

- debug:
    msg: "connectbox_os {{ connectbox_os }}"

- debug:
    msg: "ansible_kernel {{ ansible_kernel }}"

- debug:
    msg: "ansible_interfaces {{ ansible_interfaces }}"

- name: setup use of old-style interface names for predictability across devices
  file:
    dest: /etc/udev/rules.d/80-net-setup-link.rules
    src: /dev/null
    state: link
  when: ansible_virtualization_type == "NA"
  register: old_style_names

- name: Request reboot if interface naming style has changed
  set_fact:
    reboot_required: True
  when: old_style_names.changed
  tags: skip_ansible_lint


- name: Check for CM4 modules
  lineinfile:
    dest: /proc/cpuinfo
    line: "Compute Module"
  check_mode: yes
  register: CM4_present

- name: Install boot for CM4 on i2c and usbhost
  copy:
    src: config.txt 
    dest: /boot/config.txt
  when: CM4_present

- name: Install i2c modules
  copy:
    src: modules
    dest: /etc/modules
  when: connectbox_os == "raspbian"


# Check early on to see whether the OS needs to be
# rebooted to allow a disk expansion step to complete.
# This is Armbian only, but the check doesn't hurt others.
- name: Check for resize2fs reboot oracle
  stat:
    path: "/var/run/resize2fs-reboot"
  register: resize2fs_reboot

# If the oracle above exists then we shouldn't continue
- name: Fail when disk expansion is incomplete
  set_fact:
    reboot_required: True
  when: resize2fs_reboot.stat.exists == True

# Disable automated apt-y things before attempting to install packages
# unattended-upgrades and apt.systemd.daily only run on Ubuntu
- name: Stop automated apty services
  service:
    name: "{{ item }}"
    state: stopped
    enabled: no
  with_items: "{{ apty_services }}"

# We are putting the update early in the build so that we reduce the number of reboots.  This update will
# bring the kernal up to date.  We will need this when we compile the network drivers later.

- name: apt update before kernal dowloads
  apt:
    update_cache: yes 

- name: apt upgrade before kernel downloads
  apt:
    upgrade: dist
  register: dist_upgraded

- name: Setup reboot if Upgrade actually occured
  set_fact:
    reboot_required: True
  when: not "0 upgraded, 0 newly installed, 0 to remove and 0" in dist_upgraded.stdout

# Needs to happen before the initial reboot, given the job triggers actions
#  on @reboot
- name: Disable armbian auto-update processes
  file:
    path: /etc/cron.d/armbian-updates
    state: absent
  when: connectbox_os == "armbian"

- name: Disable systemd-resolve to remove port conflicts
  command: systemctl disable systemd-resolved

- name: Remove i2c0 in /boot/armbianEnv.txt
  replace:
    path: /boot/armbianEnv.txt
    regexp: 'overlays=i2c0 usbhost0 '
    replace: 'overlays='
  when: connectbox_os != "raspbian" and not aws_instance

- name: Add i2c0 to /boot/armbianEnv.txt
  replace:
    path: /boot/armbianEnv.txt
    regexp: '(overlays=)'
    replace: '\1i2c0 usbhost0 '
  when: connectbox_os != "raspbian" and not aws_instance

# The system takes 5-10 seconds to disappear from the network
#  so let's wait 15 seconds before doing our first check
#  Use newer ansible 2.7 function reboot
- name: Reboot device for changes to take effect
  reboot:
    post_reboot_delay=15
    pre_reboot_delay=2
  when: reboot_required
  tags: reboot1


- name : Increase size of /tmp to handle upcoming installs
  command: mount -o remount, size=400M /tmp/
  when: connectbox_os != "raspbian" and not aws_instance

# Unblock wlan0 and wlan1 unconditionally (not a problem if redundant)
- name: unblock wlan0
  command: /usr/sbin/rfkill unblock 0
  ignore_errors: yes
  when: connectbox_os == "raspbian"

- name: unblock wlan1
  command: /usr/sbin/rfkill unblock 1
  ignore_errors: yes
  when: connectbox_os == "raspbian"


#- name: Get current rfkill state for interface 0 (wireless LAN) on Raspbian
#  command: cat /sys/class/rfkill/rfkill0/soft
#  register: rfkill0_state
#  ignore_errors: yes
#  changed_when: False
#  when: connectbox_os != "raspbian" and not aws_instance

# Raspbian-lite buster and onwards rfkill wlan0 by default, which causes
#  problems when we try to start wlan0 (at hostapd reload)
# This change persists across reboots, so it's safe to do here.
#- name: Unblock rfkill'ed interface 0 (wireless LAN) on Raspbian
#  command: /usr/sbin/rfkill unblock 0
#  ignore_errors: yes
#  when: "connectbox_os == 'raspbian' and '0' not in rfkill0_state.stdout"

#- name: Get current rfkill state for interface 1 (wireless LAN) on Raspbian
#  command: cat /sys/class/rfkill/rfkill1/soft
#  register: rfkill1_state
#  ignore_errors: yes
#  changed_when: False
#  when: connectbox_os == "raspbian"

# Raspbian-lite buster and onwards rfkill wlan1 by default, which causes
#  problems when we try to start wlan1 (at hostapd reload)
# This change persists across reboots, so it's safe to do here.

- name: Set default locale
  lineinfile:
    path=/etc/default/locale
    state=present
    line="LC_ALL=en_US.UTF-8"
  when: connectbox_os == "armbian"

# Needed for package upgrades via ansible (aptitude safe-upgrade)
- name: Install apt
  apt:
    name: apt
    state: present

- name: Install jq so that ConnectBoxManage.sh can edit brand.txt easily
  apt:
    name: jq
    state: present

# mikegleasonjr.firewall assumes iptables but Armbian doesn't ship with it
- name: Install iptables
  apt:
    name: iptables
    state: present
  when: connectbox_os == "armbian"

# Only repopulate daily so we don't slow runs down unnecessarily
- name: Populate apt cache
  apt:
    update-cache: yes
    cache_valid_time: 86400 # 1 day

# We build our own armbian images, so we need to prevent upstream
#  kernel, dtb and uboot packages from being installed (lest they
#  overwrite our changes)
# This task will bomb if we're running on a sunxi device and using
#  something other than the "next" branch or using something other
#  than stretch
# We use aptitude instead of apt-hold because aptitude's first run clears
#  the package holds which causes us to upgrade these packages.
# aptitude doesn't give any indication about whether the package was
#  already on hold, so it's not possible to show whether this task
#  changed anything (and it's not worth lead-up tasks to work out
#  whether this task would do anything i.e. using aptitude search ~ahold
- name: Pin kernel and dtb packages
  command: "aptitude -q hold linux-dtb-current-sunxi linux-image-current-sunxi linux-u-boot-nanopineo-current linux-focal-root-current-nanopineo"
  when: connectbox_os == "armbian" and "sunxi" in ansible_kernel

# If we ever allow updates of the linux-...-root device package, this will
#  need to move into a service or some other method (noting the package
#  overwrites /etc/default/cpufrequtils)
# See https://www.kernel.org/doc/Documentation/cpu-freq/governors.txt for
#  an explanation of the governors. The choice to use conservative was
#  not driven by data, so choose something different if data is available.
- name: Enable conservative CPU frequency governor on physical devices (for next restart)
  lineinfile:
    path: /etc/default/cpufrequtils
    regexp: '^GOVERNOR='
    line: 'GOVERNOR=conservative'
  when: connectbox_os == "armbian"

# Needed by Debian Stretch
- name: Install openresolv
  apt:
    name: openresolv
    state: present
  when: ansible_lsb["id"] == "Debian"

# acl needed for good install of Postgres as per Leo-Nils 20211011
- name: Install acl
  apt:
    name: acl
    state: present

- name: Set /usr/bin/python to python3 so everything runs happy
  shell: "rm -f /usr/bin/python && sleep 2 && ln -s /usr/bin/python3 /usr/bin/python"
  
# Needed in several subsequent roles
- name: Install packages for python virtualenv
  apt:
    name: ['python3-virtualenv', 'python3-pip', 'virtualenv']
    state: present
  tags:
    - captive_portal

# Needed in several subsequent roles
- name: install git
  apt:
    name: git
    state: present

- name: Move armbian-resize filesystem
  ansible.builtin.copy:
    src: /usr/lib/armbian/armbian-resize-filesystem
    dest: /usr/lib/armbian-resize-filesystem
    remote_src: yes
    mode: preserve
  when: connectbox_os == "armbian"

# See if we need to create a wlan0 interface when we're running in a sim
#  environment i.e. running virtualised
- name: Create a wlan0 interface
  command: /sbin/ip link add wlan0 type dummy
  when: "'wlan0' not in ansible_interfaces and ansible_virtualization_type != 'NA'"

# The log files in /var/log/connectbox and /var/log/nginx are required for the
#  nginx service to run. Unfortunately, some un-identified start up code is deleting
#  those directories and causing the nginx service to fail. The following three steps
#  create the directory, install a shell script to re-establish the required directories 
#  and log files and then run that shell script at every startup.
- name: Create the /usr/local/connectbox/bin directory
  file:
    path: /usr/local/connectbox/bin
    state: directory

- name: Install CreateLogFiles.sh  
  copy: 
    src: usr_local_connectbox_bin_CreateLogFiles.sh
    dest: /usr/local/connectbox/bin/CreateLogFiles.sh
  when: (connectbox_os == "armbian") or (connectbox_os == "raspbian")


# Moved from 
- name: Make connectbox directory
  file:
    state: directory
    path: /usr/local/connectbox
    mode: 0755

- name: Install PIP
  apt:
    name: python-pip
    state: present
  ignore_errors: yes

- name: Install PIP3
  apt:
    name: python3-pip
    stat: present
  ignore_errors: yes

- name: set up resize of filesystem
  debug:
    msg: Setting up resize of filesystem
  notify:
    - Install PxUSBm.py
  changed_when: True

- name: install pexpect (needed for PxUSBm.py script)
  pip:
    name: pexpect

- name: Add items to rc.local
  blockinfile:
    path: /etc/rc.local
    insertafter: "# By default this script does nothing."
    block: |
      # Create missing log files and restart nginx service
      #  we need this or nginx won't run
      sh /usr/local/connectbox/bin/CreateLogFiles.sh   
      # script to expand the file system to use the entire uSD space and 
      #  run daemon to watch for and mount USB as required 
      /usr/bin/python3 /usr/local/connectbox/bin/PxUSBm.py &
      #  run daemon for mount USB and resize SD card
      /usr/bin/python3 /usr/local/connectbox/bin/mountCheck.py &
  when: not aws_instance

    
- name: Install mountCheck.py  
  copy: 
    src: usr_local_connectbox_bin_mountCheck.py
    dest: /usr/local/connectbox/bin/mountCheck.py
    mode: 0644
  when: connectbox_os == "armbian" or connectbox_os == 'raspbian'


- name: Copy brand.txt template
  template:
    src: brand_txt.j2
    dest: /usr/local/connectbox/brand.txt
    mode: '0666'

- name: Check for device_type CM4
  replace:
    path: /usr/local/connectbox/brand.txt
    regexp: '"Device_type": .*,'
    replace: '"Device_type": "CM",'
  when: CM4_present

- name: Remove multiple-batteries screen if not CM4
  replace:
    path: /usr/local/connectbox/brand.txt
    regexp:  '"Screen_Enable": \[.*\]'
    replace: '"Screen_Enable": [
      {{ lcd_pages_main }},
      {{ lcd_pages_info }},
      {{ lcd_pages_battery }},
      0,
      {{ lcd_pages_memory }},
      {{ lcd_pages_stats_hour_one }},
      {{ lcd_pages_stats_hour_two }},
      {{ lcd_pages_stats_day_one }},
      {{ lcd_pages_stats_day_two }},
      {{ lcd_pages_stats_week_one }},
      {{ lcd_pages_stats_week_two }},
      {{ lcd_pages_stats_month_one }},
      {{ lcd_pages_stats_month_two }},
      {{ lcd_pages_admin }}
      ]'
  when: not CM4_present  

- name: Check for device_type PI
  replace:
    path: /usr/local/connectbox/brand.txt
    regexp: '"Device_type": *,'
    replace: '"Device_type": "PI",'
  when: connectbox_os == "raspbian" and not CM4_present
        
- name: Cause phonehome.py to execute every 10 minutes via cron IF not a Moodle box  (We have different process for Moodle)
  ansible.builtin.cron:
    name: "phonehome.py"
    minute: "*/10"
    user: www-data
    job: "/usr/bin/python /usr/local/connectbox/bin/phonehome.py >/tmp/push_messages.log  2>&1"
  when: not build_moodle
